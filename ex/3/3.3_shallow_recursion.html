<html>
	<head>
		<title>Ex 3.3</title>
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
		</style>
		<script src="../../lib/three.min.js"></script>
		<script src="../../lib/stats.min.js"></script>
	</head>
	<body>
		
		<script>

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xf0f0f0);
			document.body.appendChild(renderer.domElement);

			var geometry = new THREE.Geometry();

			// build initial octahedron; use 3 vertices for each face for simplicity
			var trisGeometry = new THREE.Geometry();
			var p = 1 / Math.sqrt(2);
			trisGeometry.vertices.push(new THREE.Vector3(-p, 0, p));
			trisGeometry.vertices.push(new THREE.Vector3(p, 0, p));
			trisGeometry.vertices.push(new THREE.Vector3(0, 1, 0));
			trisGeometry.faces.push(new THREE.Face3(0, 1, 2));

			for (var i = 0; i < 4; i++) {
				geometry.merge(trisGeometry.rotateY(i * Math.PI/2));
				geometry.merge(trisGeometry.rotateX(Math.PI));
			}

			function subdivide(n) {

				if (n > 0) {
					var f = geometry.faces.length, v = 3 * f;
					for (var i = 0; i < f; i++) {						// for each old face
						var face = geometry.faces[0];
						var old_vertices = [ face.a, face.b, face.c ];	// get indexes for old face vertices
						geometry.faces.splice(0, 1);					// remove old face

						var new_vertices = [];
						for (var j = 0; j < 3; j++) {					// for each edge of the old face
							new_vertices[j] = new THREE.Vector3();
							for (var k = 0; k < 3; k++) {				// compute mean point in a convenient order
								new_vertices[j].setComponent(k, (
									geometry.vertices[old_vertices[(j+1)%3]].getComponent(k) +
									geometry.vertices[old_vertices[(j+2)%3]].getComponent(k)) / 2
								);
							}
							new_vertices[j].normalize();				// project mean point on sphere
						}
						for (var j = 0; j < 3; j++) {					// add new corner faces & vertices
							geometry.vertices.push(new_vertices[(j+2)%3].clone());
							geometry.vertices.push(new_vertices[(j+1)%3].clone());
							geometry.faces.push(new THREE.Face3(old_vertices[j], v++, v++));
						}
						for (var j = 0; j < 3; j++) {					// add new center face & vertices
							geometry.vertices.push(new_vertices[j]);
						}
						geometry.faces.push(new THREE.Face3(v++, v++, v++));
					}
					subdivide(n - 1);
				}
			}

			subdivide(findGetParameter('n'));	// use HTML GET parameter n

			var material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
			var sphere = new THREE.Mesh(geometry, material);
			sphere.position.y = 0.5;
			scene.add(sphere);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);

			camera.position.z = 5;
			
			function render() {
				requestAnimationFrame(render);
				
				sphere.rotation.y += 0.01;

				stats.update();
				
				renderer.render(scene, camera);
			}
			render();

			/* ----------------------------------------------------------------------------------*/
			function findGetParameter(parameterName) {

			    var items = location.search.substr(1).split("&");
			    for (var i = 0; i < items.length; i++) {
			    	var tmp = items[i].split("=");
			        if (tmp[0] === parameterName) {
			        	return decodeURIComponent(tmp[1]);
			        }
			    }
			    return null;
			}

		</script>
		<div style="position:absolute; top:0; left:0; right:0; margin:0 auto; text-align:center">
			<form method="get">n <input type="text" name="n" style="width:20px" autofocus></form>
		</div>
	</body>
</html>