<html>
	<head>
		<title>Ex 3.3</title>
		<style>
		body {
			font-family: Monospace;
			background-color: #f0f0f0;
			margin: 0px;
			overflow: hidden;
		}
		
		canvas { 
			width: 100%; 
			height: 100%;
		}
		</style>
		<script src="../../lib/three.min.js"></script>
		<script src="../../lib/stats.min.js"></script>
	</head>
	<body>
		
		<script>

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

			var renderer = new THREE.WebGLRenderer();
			renderer.setSize(window.innerWidth, window.innerHeight);
			renderer.setClearColor(0xf0f0f0);
			document.body.appendChild(renderer.domElement);

			var geometry = new THREE.Geometry();

			// build initial octahedron; use 3 vertices for each face for simplicity
			var trisGeometry = new THREE.Geometry();
			var p = 1 / Math.sqrt(2);
			trisGeometry.vertices.push(new THREE.Vector3(-p, 0, p));
			trisGeometry.vertices.push(new THREE.Vector3(p, 0, p));
			trisGeometry.vertices.push(new THREE.Vector3(0, 1, 0));
			trisGeometry.faces.push(new THREE.Face3(0, 1, 2));

			for (var i = 0; i < 4; i++) {
				geometry.merge(trisGeometry.rotateY(i * Math.PI/2));
				geometry.merge(trisGeometry.rotateX(Math.PI));
			}

			function subdivide(n) {

				var f = geometry.faces.length, v = 3 * f;
				for (var i = 0; i < f; i++) {			// for each old face
					v = subdivide_face(geometry.faces[0], v, n);
					geometry.faces.splice(0, 1);		// remove old face
				}
			}

			function subdivide_face(old_face, v, n) {

				if (n > 0) {
														// get indexes for old face vertices
					var old_vertices = [ old_face.a, old_face.b, old_face.c ];
					var new_vertices = [];
					
					for (var j = 0; j < 3; j++) {		// for each edge of the old face
						new_vertices[j] = new THREE.Vector3();
						for (var k = 0; k < 3; k++) {	// compute mean point in a convenient order
							new_vertices[j].setComponent(k, (
								geometry.vertices[old_vertices[(j+1)%3]].getComponent(k) +
								geometry.vertices[old_vertices[(j+2)%3]].getComponent(k)) / 2
							);
						}
						new_vertices[j].normalize();	// project mean point on sphere
					}

					for (var j = 0; j < 3; j++) {		// add new corner faces & vertices
						geometry.vertices.push(new_vertices[(j+2)%3].clone());
						geometry.vertices.push(new_vertices[(j+1)%3].clone());
						v = subdivide_face(new THREE.Face3(old_vertices[j], v++, v++), v, n - 1);
					}
					for (var j = 0; j < 3; j++) {		// add new center face & vertices
						geometry.vertices.push(new_vertices[j]);
					}
					return subdivide_face(new THREE.Face3(v++, v++, v++), v, n - 1);
				} else {
					geometry.faces.push(old_face);
					return v;
				}
			}

			subdivide(findGetParameter('n'));	// use HTML GET parameter n

			var material = new THREE.MeshBasicMaterial({ color: 0xff0000, wireframe: true });
			var sphere = new THREE.Mesh(geometry, material);
			sphere.position.y = 0.5;
			scene.add(sphere);

			stats = new Stats();
			stats.domElement.style.position = 'absolute';
			stats.domElement.style.top = '0px';
			document.body.appendChild(stats.domElement);

			camera.position.z = 5;
			
			function render() {
				requestAnimationFrame(render);
				
				sphere.rotation.y += 0.01;

				stats.update();
				
				renderer.render(scene, camera);
			}
			render();

			/* ----------------------------------------------------------------------------------*/
			function findGetParameter(parameterName) {

			    var items = location.search.substr(1).split("&");
			    for (var i = 0; i < items.length; i++) {
			    	var tmp = items[i].split("=");
			        if (tmp[0] === parameterName) {
			        	return decodeURIComponent(tmp[1]);
			        }
			    }
			    return null;
			}

		</script>
		<div style="position:absolute; top:0; left:0; right:0; margin:0 auto; text-align:center">
			<form method="get">n <input type="text" name="n" style="width:20px" autofocus></form>
		</div>
	</body>
</html>